#!/bin/bash

#
# Arch GNU/Linux installer
# 
# Copyright (C) Patryk Jaworski <regalis@regalis.com.pl>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 

#
# Core::globals
#

TARGET="" # target directory
ARCHITECTURE="" # target architecture
HOOKS="" # hooks list
PACKAGES="" # target packages
CONFIGURATION=()
CONFIGURATION_INCLUDE_FILE=""
declare -A CONFIGURATION_HOOKS
ERRORS=0
WARNINGS=0
WERR=0 # Treat warnings as errors

#
# Core::decorations
#

BOLD=$(tput bold)
CSTD=$(tput sgr0)
CRED=$(tput setf 4)
CGRN=$(tput setf 2)
CYLW=$(tput setf 6)

#
# Utils::output
#

MSG_CONTEXT=""

info() {
	echo "[I]${MSG_CONTEXT} $@"
}

warn() {
	let WARNINGS++
	echo "${CYLW}[W]${CSTD}${MSG_CONTEXT} $@"
}

err() {
	let ERRORS++
	echo "${CRED}[E]${CSTD}${MSG_CONTEXT} $@" 1>&2
}

log() {
	echo $@ > log
}

ask() {
	echo -n "$1 (y/N): "
	read ANSWER
	echo
	if [[ "$ANSWER" =~ ^[Yy]$ ]]; then
		return 0;
	else
		return 1;
	fi;
}

set_context() {
	MSG_CONTEXT="$1"
}

clear_context() {
	MSG_CONTEXT=""
}

#
# Utils::configuration
#

# Arguments:
#  $1 - variable name (string)
#  $2 - default value (string)
#  $3 - description (string)
#  $4 - required (optional, if set - variable is marked as required)
config_add() {
	info "Hook: ${HOOK}"
	info "Registering request for new configuration variable: '$1'"

	CONFIGURATION=(${CONFIGURATION[@]} ${1})
	CONFIGURATION_HOOKS[${HOOK}]="${CONFIGURATION_HOOKS[${HOOK}]} ${1}"
	
	if [[ -n "$2" ]]; then
		export CONF_$1_DEFAULT="$2"
	else
		info "Variable '$1' has no default value..."
	fi
	if [[ -n "$3" ]]; then
		export CONF_$1_DESCRIPTION="$3"
	fi
	if [[ -n "$4" ]]; then
		export CONF_$1_REQUIRED=1
	fi
}

# Arguments
# $1 - set defaults (if set, empty variables will be filled with defualt value)
config_dump() {
	echo -e "#!/bin/bash\n"
	for HOOK_NAME in "${!CONFIGURATION_HOOKS[@]}"; do
		for VAR_NAME in ${CONFIGURATION_HOOKS[${HOOK_NAME}]}; do
			VAR_DSC="CONF_${VAR_NAME}_DESCRIPTION"
			VAR_DEF="CONF_${VAR_NAME}_DEFAULT"

			echo "# Requested by hook \"${HOOK_NAME}\""
			if [[ -v "${VAR_DEF}" ]]; then
				echo "# Default value: \"${!VAR_DEF}\""
			fi

			if [[ -v "${VAR_DSC}" ]]; then
				echo "#"
				echo "${!VAR_DSC}" | fold -s | awk '{ print "# " $0 }'	
				echo -e "#"
			fi
			
			if [[ -n "${1}" ]]; then
				echo "${VAR_NAME}='${!VAR_DEF}'"
			else
				echo "${VAR_NAME}=''"
			fi
			echo
		done
	done
}

config_check() {
	ERRORS=0
	for HOOK_NAME in "${!CONFIGURATION_HOOKS[@]}"; do
		for VAR_NAME in ${CONFIGURATION_HOOKS[${HOOK_NAME}]}; do
			VAR_DEF="CONF_${VAR_NAME}_DEFAULT"
			VAR_REQ="CONF_${VAR_NAME}_REQUIRED"

			if test -z "${!VAR_NAME}" -a -n "${!VAR_DEF}"; then
				info "Undefined variable \"${VAR_NAME}\" which is required by hook ${HOOK_NAME}"
				info "Using default value = " "${!VAR_DEF}"
				export ${VAR_NAME}="${!VAR_DEF}"
			fi

			if test -z "${!VAR_NAME}" -a -v "${VAR_REQ}"; then
				err "Undefined variable \"${VAR_NAME}\" which is required by hook ${HOOK_NAME}"
			fi

		done
	done
	if [[ ! ${ERRORS} -eq 0 ]]; then
		err "Configuration stage error. Exiting..."
		exit 10
	fi
}

config_include() {
	if [[ ! -f "${CONFIGURATION_INCLUDE_FILE}" ]]; then
		err "Unable to find configuration file ${CONFIGURATION_INCLUDE_FILE}"
		exit 2
	fi
	
	info "Loading configuration file ${CONFIGURATION_INCLUDE_FILE}"

	source "${CONFIGURATION_INCLUDE_FILE}"

	if [[ ! $? -eq 0 ]]; then
		err "Configuration file contain errors..."
		exit 2
	fi
}

#
# Utils::hooks
#

# $1 - stage (preinstall/postinstall etc.)
run_hooks() {
	ERRORS=0
	WARNINGS=0
	if [[ $1 != "install" ]]; then
		for HOOK in $HOOKS; do
			NAME=$(echo hook_${HOOK}_$1)
			type $NAME > /dev/null 2>&1
			if [[ $? -eq 0 ]]; then
				set_context "[$1]"
				info "Running hook $HOOK"
				set_context "  [$HOOK] "
				$NAME;
				clear_context
			fi
		done
	else
		NAME=$(echo hook_${INSTALL_HOOK}_$1)
		type $NAME > /dev/null 2>&1
		if [[ $? -eq 0 ]]; then
			set_context "[$1]"
			info "Running install hook ${INSTALL_HOOK}"
			set_context "  [${INSTALL_HOOK}] "
			$NAME;
			clear_context
		fi
			
	fi;

	if [[ ${ERRORS} -gt 0 ]]; then
		info "Errors in stage $1"
		info "Exiting installation due to previous error messages: ${ERRORS}"
		exit 10
	fi

	if [[ ${WARNINGS} -gt 0 ]]; then
		info "Warnings in stage $1"
		if [[ "${WERR}" = "1" ]]; then
			info "Exiting installation due to previous warning messages (-e): ${WARNINGS}"
			exit 5
		fi
	fi
}

#
# Utils::packages
#

add_packages() {
	PACKAGES="$PACKAGES $@"
}

set_install_hook() {
	INSTALL_HOOK=$1;
}

#
# Utils::mount
#

MOUNTPOINTS=();

#
# $1 - device
# $2 - dir
# $3 - type
# $4..n options passed directly to mount
#
do_mount() {
	local DEVICE=$1
	local DIR=$2
	local TYPE=$3
	shift 3
    info "Trying to mount $TYPE ($DEVICE) on $DIR"
	mount -t ${TYPE} ${DEVICE} ${DIR} $@ && MOUNTPOINTS=("${DIR}" "${MOUNTPOINTS[@]}")
    if [[ ! $? -eq 0 ]]; then
        err "Unable to mount $DEVICE";
        return 1
    fi
}

#
# Core::pacman
#

# $1..n packages
install_packages() {
	pacman -r ${TARGET} --noconfirm --quiet --noprogressbar --needed -Sy $@
}

# $1..n packages
remove_packages() {
	pacman -r ${TARGET} --noconfirm --quiet --noprogressbar -R $@
}


#
# Core::chroot
#

# $1 - program
# $2..n program args
#
chroot_exec() {
	info "[chroot] Executing command: " $@
	chroot ${TARGET} $@
}

#
# Hooks::core
#
# Common hooks
# 
# hook_NAME_preconfigure - will be executed before "configure" hook
# hook_NAME_configure - will be executed as a configure hook
# hook_NAME_preinstall - will be executed before install hook
# hook_NAME_install - will be execeted as a main install routine
# hook_NAME_postinstall - will be executed after install hook
# hook_NAME_desc - will be executed when help requested
#

hook_detect_architecture_configure() {
	info "detecting architecture";
	ARCHITECTURE=i686
	grep '^flags.* lm ' /proc/cpuinfo > /dev/null 2>&1 && ARCHITECTURE=x86_64
	info "architecture detected as ${ARCHITECTURE}"
}

hook_base_preinstall() {
	info "adding base packages"
	add_packages "base vim net-tools";
}

hook_gnome_preinstall() {
	info "adding gnome packages"
	add_packages "gnome gnome-extra gnome-tweak-tool"
}

hook_xfce_preinstall() {
	info "adding xfce packages"
	add_packages "xfce4 xfce4-goodies evince"
}

hook_pacman_preconfigure() {
	config_add ARCHITECTURE '' 'Packages architecture' required
	config_add TARGET '' 'Target directory' required
}

hook_pacman_preinstall() {
	info 'Creating required directories inside target directory...'
	mkdir -p $TARGET/var/lib/pacman || err "Unable to create directory in ${TARGET}"
	info "setting install hook"
	set_install_hook pacman
}

hook_pacman_install() {
	info "installing packages"
	install_packages ${PACKAGES}
	if [[ $? -eq 0 ]]; then
		info "all packages installed"
	else
		err "pacman exited with $?"
	fi
}

prepare_chroot_cleanup() {
	set_context "[prepare_chroot]"
	umount ${MOUNTPOINTS[@]} && info "chroot cleanup: OK"
}

hook_prepare_chroot_preinstall() {
	trap "prepare_chroot_cleanup" EXIT SIGINT SIGTERM
    mkdir ${TARGET}/{proc,sys,dev,dev/pts,etc}
    touch ${TARGET}/etc/resolv.conf
	do_mount /dev "${TARGET}/dev" devtmpfs -o bind &&
	do_mount proc "${TARGET}/proc" proc -o nosuid,nodev,noexec &&
	do_mount sys "${TARGET}/sys" sysfs -o nosuid,nodev,noexec &&
	do_mount devpts "${TARGET}/dev/pts" devpts -o gid=5,mode=620  &&
	do_mount /etc/resolv.conf "${TARGET}/etc/resolv.conf" resolv -o bind
}

hook_prepare_chroot_cleanup_postinstall() {
	umount ${MOUNTPOINTS[@]} && info "chroot cleanup: OK"
}

hook_build_mkcinitcpio_postinstall() {
	chroot "${TARGET}" mkinitcpio -p linux
}

#
# Diskless environment
#

hook_mkinitcpio_squashfs_preinstall() {
	add_packages binutils make wget pv fakeroot git findutils sudo mkinitcpio-nfs-utils
}

# mkinitcpio-squashfs hook
# 
# * download and build mkinitramfs-squashfs package source from Github.com/Regalis
# * install mkinitramfs-squashfs package
# 
hook_mkinitcpio_squashfs_postinstall() {
	pacman -r ${TARGET} -Qq mkinitcpio-squashfs-git > /dev/null 2>&1 || { 
	cat <<EOF > ${TARGET}/home/build/build.sh
#/bin/bash
cd ~
wget "https://raw.githubusercontent.com/Regalis/mkinitramfs-squashfs/develop/dist/archlinux/PKGBUILD"
makepkg -f
find -name *.pkg.tar.xz -execdir mv '{}' mkinitcpio-squashfs \;
EOF
	info "Building mkinitcpio-squashfs package"
	chroot_exec sudo -u build -- bash /home/build/build.sh
	info "Installing package mkinitcpio-squashfs-git"
	pacman -r ${TARGET} -U ${TARGET}/home/build/mkinitcpio-squashfs --noconfirm --noprogressbar ||
		err "Unable to install package"
	}
}

hook_diskless_preconfigure() {
	config_add 'DISKLESS_INITRAM_MODULES' 'forcedeth e1000' \
		"Kernel modules included in initial RAM disk" required
}

hook_diskless_preinstall() {
    add_packages mkinitcpio-nfs-utils
}

#
# Diskless postinstall hook
# * prepare mkinitcpio.conf:
#   * add initram modules (see DISKLESS_INITRAM_MODULES variable)
#   * add squashfs and net hooks
#   * remove fsck hook
# 
hook_diskless_postinstall() {
# TODO: learn sed
# TODO: fix sed rubbish

	grep -e "^MODULES=\(.*${DISKLESS_INITRAM_MODULES}.*\)" ${TARGET}/etc/mkinitcpio.conf ||
		{ info "Adding additional modules to mkinitcpio.conf"; sed -i.bak -r -e "s/^MODULES=\((.*)\)/MODULES=\(\1 ${DISKLESS_INITRAM_MODULES}\)/" ${TARGET}/etc/mkinitcpio.conf; }
	
	grep -e '^HOOKS=(.*net block squashfs.*)' ${TARGET}/etc/mkinitcpio.conf ||
        { info "Adding net, squashfs hooks to mkinitcpio.conf"; sed -i.bak -r -e 's/^(HOOKS=\()(.*)block(.*)\)/\1\2net block squashfs\3\)/' -e 's/^(HOOKS=\()(.*) fsck(.*)\)/\1\2\3\)/' ${TARGET}/etc/mkinitcpio.conf; }

}

hook_mkinitcpio_disable_autodetect_postinstall() {
	grep -e '^HOOKS=(.*autodetect*)' ${TARGET}/etc/mkinitcpio.conf ||
        { info "Disabling autodetect in /etc/mkinitcpio.conf"; sed -i.bak -r -e 's/^(HOOKS=\()(.*) autodetect(.*)\)/\1\2\3\)/' ${TARGET}/etc/mkinitcpio.conf; } 
}

hook_squashfs_preconfigure() {
	config_add 'SQUASHFS_FILE_PATH' '/tmp/root.sfs' \
		"Save Squashfs archive in this location (absolute path)" required
}

hook_squashfs_postinstall() {
	SQUASHFS_DIR=`dirname ${SQUASHFS_FILE_PATH}`

	if [[ ! -d "${SQUASHFS_DIR}" ]]; then
		info "Creating directory for squashfs image..."
		mkdir -p ${SQUASHFS_DIR}
		if [[ ! $? -eq 0 ]]; then
			err "Unable to create output direcotry..."
			return 1
		fi
	fi

	info "Creating exclude file..."
	EF="$(mktemp)"

	echo "./boot" > $EF
	echo "./usr/share/gtk-doc" >> $EF
	echo "./usr/share/man" >> $EF
	echo "./usr/share/doc" >> $EF
	echo "./lib/firmware" >> $EF
	echo "./usr/include" >> $EF
	echo "./var/lib/pacman" >> $EF
	echo "./usr/lib/pacman" >> $EF
	echo "./usr/include" >> $EF

	info "Creating system image..."
	( cd ${TARGET}; mksquashfs . ${SQUASHFS_FILE_PATH} -ef ${EF} )
	info "System image ready..."
	rm ${EF}
}

#
# Schemes helpers
#

REGISTERED_SCHEMES=();

# $1..$n schemes
register_scheme() {
	for X in $@; do
		REGISTERED_SCHEMES=("${X}" "${REGISTERED_SCHEMES[@]}");
	done
}

#
# Default schemes
#

SCHEME_base="detect_architecture base pacman prepare_chroot build_mkcinitcpio"
SCHEME_diskless="${SCHEME_base/prepare_chroot/prepare_chroot diskless mkinitcpio_disable_autodetect}"

register_scheme base diskless

usage() {
	echo "Usage: $0 [-t TARGET_DIRECTORY] [-a ARCHITECTURE] -s HOOKS_SCHEME"
	echo "Options: "
	echo "   -a ARCH      architecture"
	echo "   -d FILE      dump configuration file and exit"
	echo "   -e           treat all warnings as errors"
	echo "   -h           display help"
	echo "   -i FILE      include configuration file"
	echo "   -s SCHEME    hooks scheme"
	echo "   -t DIR       target directory"
	echo "Available schemes:"
	for S in ${REGISTERED_SCHEMES[@]}; do
		echo " -> $S"
		SCHEME_HOOKS=$(echo SCHEME_${S})
		SCHEME_HOOKS=$(echo ${!SCHEME_HOOKS})
		for HOOK_NAME in $SCHEME_HOOKS; do
			echo "    * $HOOK_NAME"
		done
	done
}

parse_options() {
	while getopts "a:d:ehi:s:t:" opt; do
		case $opt in
			"a")
				ARCHITECTURE=$OPTARG
			;;
			"d")
				CONFIGURATION_DUMP=$OPTARG
				info "Program will run in \"configuration dump\" mode..."
			;;
			"e")
				info "Treating warnings as errors"
				WERR=1
			;;
			"h")
				usage
				exit 0
			;;
			"i")
				CONFIGURATION_INCLUDE_FILE=$OPTARG
			;;
			"s")
				HOOKS=$(echo SCHEME_${OPTARG})
				HOOKS=${!HOOKS}
			;;
			"t")
				TARGET=$OPTARG
			;;
			":")
				err "Option -$OPTARG requires an argument..."
				exit -1
			;;
			"?")
				err "Unknown option -$OPTARG..."
				exit -2
			;;
		esac;
	done;
}

main() {
	parse_options $@

	if [[ -z "${HOOKS}" ]]; then
		err "Hooks not set, did you forget -s option?"
		exit 1
	fi

	run_hooks "preconfigure"

	if [[ -n "${CONFIGURATION_DUMP}" ]]; then
		config_dump defaults > "${CONFIGURATION_DUMP}"
		info "Configuration file dumped to ${CONFIGURATION_DUMP}"
		exit 0
	fi

	if [[ -n "${CONFIGURATION_INCLUDE_FILE}" ]]; then
		info "Including configuration"
		config_include
	fi

	run_hooks "configure"

	config_check

	run_hooks "preinstall"

	if [[ -z "$INSTALL_HOOK" ]]; then
		err "Install hook not specified. Exiting"
		exit 4;
	fi;

	info "Configuration:"
	info "    Hooks          : ${HOOKS}"
	info "    Directory      : ${TARGET}"
	info "    Architecture   : ${ARCHITECTURE}"
	info "    Packages       : ${PACKAGES}"

	ask "Continue?" || { warn "Aborting..."; exit 1; }
	
	run_hooks "install"
	run_hooks "postinstall"
	echo;
}

[[ $0 != ${BASH_SOURCE} ]] || main $@
# vim: ft=sh :
